-- ============================================================
-- CODEHERO MASTER INSTALLATION SCRIPT (v2.2)
-- ============================================================
-- Usage: Run this entire script in the Supabase SQL Editor.
-- This sets up the complete database schema, security policies,
-- and admin functions required for the application.

-- 1. ENABLE ROW LEVEL SECURITY (Base)
alter table auth.users enable row level security;

-- 2. PUBLIC TABLES

-- PROFILES
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  email text, -- Added for Admin Panel management
  avatar_svg text,
  role text default 'user' check (role in ('user', 'admin')),
  -- Bot & Leaderboard Fields
  is_bot boolean default false,
  bot_score int default 0,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- WORLDS
create table if not exists public.worlds (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  style text, -- 'cyberpunk', 'matrix', etc
  level_range int[] -- e.g. {1, 10}
);
alter table public.worlds enable row level security;
drop policy if exists "Worlds are private." on worlds;
create policy "Worlds are private." on worlds for select using (auth.role() = 'authenticated');
drop policy if exists "Admins can edit worlds." on worlds;
create policy "Admins can edit worlds." on worlds for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- PHASES
create table if not exists public.phases (
  id bigint generated by default as identity primary key,
  world_id bigint references public.worlds not null,
  title text not null,
  description text,
  order_index int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now())
);
alter table public.phases enable row level security;
drop policy if exists "Phases are public." on phases;
create policy "Phases are private." on phases for select using (auth.role() = 'authenticated');
drop policy if exists "Admins can edit phases." on phases;
create policy "Admins can edit phases." on phases for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- LEVEL TYPES
create table if not exists public.level_types (
  id bigint generated by default as identity primary key,
  name text unique not null,
  slug text,
  description text,
  icon text, -- Emoji or SVG
  color text default '#4CAF50',
  config_schema JSONB DEFAULT '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now())
);
alter table public.level_types enable row level security;
drop policy if exists "Level Types are private." on level_types;
create policy "Level Types are private." on level_types for select using (auth.role() = 'authenticated');
drop policy if exists "Admins can edit level types." on level_types;
create policy "Admins can edit level types." on level_types for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- LEVELS
create table if not exists public.levels (
  id bigint generated by default as identity primary key,
  phase_id bigint references public.phases not null,
  title text not null,
  type text,
  description text,
  map jsonb,
  start_pos jsonb,
  end_pos jsonb,
  perfect_score int,
  stars_2_threshold int,
  stars_1_threshold int,
  hint text,
  difficulty int default 1,
  start_code jsonb default '[]'::jsonb, -- New: For debug
  created_at timestamp with time zone default timezone('utc'::text, now())
);
alter table public.levels enable row level security;
drop policy if exists "Levels are private." on levels;
create policy "Levels are private." on levels for select using (auth.role() = 'authenticated');
drop policy if exists "Admins can edit levels." on levels;
create policy "Admins can edit levels." on levels for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- PROGRESS 
create table if not exists public.progress (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles not null,
    level_id bigint references public.levels not null,
    status text, -- 'completed', etc
    score int,
    stars int,
    code_snapshot jsonb,
    completed_at timestamp with time zone default now(),
    unique(user_id, level_id)
);
alter table public.progress enable row level security;
drop policy if exists "Users manage own progress" on progress;
create policy "Users manage own progress" on progress for all using (auth.uid() = user_id);
drop policy if exists "Admins view all progress" on progress;
create policy "Admins view all progress" on progress for select using (
    exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- PROFILES RLS (Strict)
alter table public.profiles enable row level security;
drop policy if exists "Users can see own profile." on profiles;
create policy "Users can see own profile." on profiles for select using (auth.uid() = id);
drop policy if exists "Users can update own profile." on profiles;
create policy "Users can update own profile." on profiles for update using (auth.uid() = id);
drop policy if exists "Admins can manage all profiles." on profiles;
create policy "Admins can manage all profiles." on profiles for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);


-- ====================
-- RPCS (Functions)
-- ====================

-- 1. HELPER: IS ADMIN
create or replace function public.is_admin()
returns boolean
language plpgsql security definer
as $$
begin
  return exists (select 1 from public.profiles where id = auth.uid() and role = 'admin');
end;
$$;

-- 2. UPDATE USER EMAIL (Admin)
DROP FUNCTION IF EXISTS public.update_user_email_admin(uuid, text);
CREATE OR REPLACE FUNCTION public.update_user_email_admin(target_user_id uuid, new_email text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'Access Denied'; END IF;
  UPDATE auth.users SET email = new_email, email_confirmed_at = now(), updated_at = now() WHERE id = target_user_id;
  UPDATE public.profiles SET email = new_email WHERE id = target_user_id;
END;
$$;

-- 3. DELETE USER (Admin)
DROP FUNCTION IF EXISTS public.delete_user_admin(uuid);
CREATE OR REPLACE FUNCTION public.delete_user_admin(target_user_id uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'Access Denied'; END IF;
  DELETE FROM public.progress WHERE user_id = target_user_id;
  DELETE FROM public.profiles WHERE id = target_user_id;
  DELETE FROM auth.users WHERE id = target_user_id;
END;
$$;

-- 4. CREATE BOT (Admin)
create or replace function public.create_bot(
  id uuid,
  username text,
  avatar_svg text,
  is_bot boolean,
  bot_score int,
  is_active boolean
) returns void language plpgsql security definer as $$
BEGIN
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'Access Denied'; END IF;
  insert into auth.users (id, email, role, raw_user_meta_data) values (id, 'bot_' || id || '@codehero.local', 'authenticated', '{"is_bot":true}'::jsonb);
  insert into public.profiles (id, username, avatar_svg, is_bot, bot_score, is_active) values (id, username, avatar_svg, is_bot, bot_score, is_active);
END;
$$;

-- 5. GET LEADERBOARD (FIXED AMBIGUITY)
DROP FUNCTION IF EXISTS public.get_leaderboard();
create or replace function public.get_leaderboard()
returns table (
  username text,
  avatar_svg text,
  is_bot boolean,
  score bigint,
  rank bigint
) language plpgsql security definer as $$
DECLARE
  v_max_human_score bigint;
BEGIN
  -- Calculate Max Human Score (Strict Aliasing)
  SELECT COALESCE(MAX(sub.total_s), 100) INTO v_max_human_score
  FROM (
      SELECT SUM(prog.score) as total_s 
      FROM public.progress prog
      JOIN public.profiles prof ON prog.user_id = prof.id
      WHERE prof.is_bot = false AND prof.is_active = true
      GROUP BY prof.id
  ) sub;

  -- Return Leaderboard
  RETURN QUERY
  SELECT 
    prof.username,
    prof.avatar_svg,
    prof.is_bot,
    CASE WHEN prof.is_bot THEN (v_max_human_score * prof.bot_score / 100)::bigint
         ELSE COALESCE(SUM(prog.score), 0)::bigint END as final_score,
    RANK() OVER (ORDER BY (
        CASE WHEN prof.is_bot THEN (v_max_human_score * prof.bot_score / 100)
             ELSE COALESCE(SUM(prog.score), 0) END
    ) DESC) as rank
  FROM public.profiles prof
  LEFT JOIN public.progress prog ON prof.id = prog.user_id
  WHERE prof.is_active = true
  GROUP BY prof.id, prof.username, prof.avatar_svg, prof.is_bot, prof.bot_score
  ORDER BY final_score DESC LIMIT 50;
END;
$$;

-- Grant Executions
grant execute on function public.update_user_email_admin to authenticated;
grant execute on function public.delete_user_admin to authenticated;
grant execute on function public.create_bot to authenticated;
grant execute on function public.get_leaderboard to authenticated;
grant execute on function public.is_admin to authenticated;


-- ====================
-- SEED DATA & RESET
-- ====================

-- FUNCTION: RESET LEVEL DATA
create or replace function public.reset_level_data()
returns void language plpgsql security definer as $$
BEGIN
    IF NOT public.is_admin() THEN RAISE EXCEPTION 'Access Denied'; END IF;

    -- HARD RESET (Order matters)
    DELETE FROM public.progress;    
    DELETE FROM public.levels;
    DELETE FROM public.phases;
    DELETE FROM public.level_types; 
    DELETE FROM public.worlds;

    -- RESTART SEQUENCES
    ALTER SEQUENCE public.worlds_id_seq RESTART WITH 1;
    ALTER SEQUENCE public.phases_id_seq RESTART WITH 1;
    ALTER SEQUENCE public.level_types_id_seq RESTART WITH 1;
    ALTER SEQUENCE public.levels_id_seq RESTART WITH 1;

    -- 1. RESTORE LEVEL TYPES (Corrected Colors)
    INSERT INTO public.level_types (name, slug, color, icon, description) VALUES
    ('Tutorial', 'tutorial', '#10b981', 'üó∫Ô∏è', 'Nivel introductorio'),
    ('B√°sico', 'basic', '#3b82f6', 'üü¶', 'Movimientos simples'),
    ('Giros', 'turns', '#8b5cf6', '‚Ü™Ô∏è', 'Aprender a rotar'),
    ('Bucles', 'loops', '#f59e0b', 'üîÑ', 'Repeticiones eficientes'),
    ('Condicionales', 'conditionals', '#ec4899', '‚ùì', 'Toma de decisiones'),
    ('Portales', 'portals', '#06b6d4', 'üåÄ', 'Teletransporte l√≥gico'),
    ('Debugging', 'debug', '#ef4444', 'üêõ', 'Reparaci√≥n de c√≥digo'),
    ('Boss', 'boss', '#ffffff', 'üèÜ', 'El desaf√≠o final')
    ON CONFLICT (name) DO UPDATE SET 
    color=EXCLUDED.color, icon=EXCLUDED.icon, description=EXCLUDED.description;

    -- 2. RESTORE WORLDS
    INSERT INTO public.worlds (title, description, style, level_range) VALUES
    ('Mundo 1: L√≥gica & Algoritmos', 'Aprende los fundamentos de la programaci√≥n.', 'cyberpunk', '{0,13}'),
    ('Mundo 2: La Base de Datos', 'Niveles avanzados de reparaci√≥n (Debugging) y optimizaci√≥n.', 'matrix', '{14,20}');

    -- 3. RESTORE PHASES 
    INSERT INTO public.phases (world_id, title, description, order_index) VALUES
    (1, 'Secuenciaci√≥n', 'Pasos b√°sicos.', 1),
    (1, 'Orientaci√≥n', 'Giros.', 2),
    (1, 'Bucles & Patron', 'Repetici√≥n.', 3),
    (1, 'Estado (Llaves)', 'Condicionales.', 4),
    (1, 'L√≥gica Avanzada', 'Portales.', 5),
    (2, 'Reparaci√≥n (Debugging)', 'Fix broken code.', 1);

    -- 4. RESTORE LEVELS 
     INSERT INTO public.levels (phase_id, title, type, map, start_pos, end_pos, perfect_score, start_code, difficulty) VALUES 
    (1, 'El Primer Paso', 'Tutorial', '[[1,1,1,1],[1,0,0,1],[1,1,1,1]]'::jsonb, '{"x":1,"y":1,"dir":1}'::jsonb, '{"x":2,"y":1}'::jsonb, 2, '[]'::jsonb, 1),
    (1, 'Doble Paso', 'Basic', '[[1,1,1,1],[1,0,0,1],[1,1,1,1]]'::jsonb, '{"x":1,"y":1,"dir":1}'::jsonb, '{"x":3,"y":1}'::jsonb, 2, '[]'::jsonb, 1);
    
END;
$$;
grant execute on function public.reset_level_data to authenticated;

SELECT 'Ready to Install. Run select public.reset_level_data() manually if needed.' as status;
