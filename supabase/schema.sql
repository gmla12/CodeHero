-- ============================================================
-- CODEHERO MASTER INSTALLATION SCRIPT
-- ============================================================
-- Usage: Run this entire script in the Supabase SQL Editor.
-- This sets up the complete database schema, security policies,
-- and admin functions required for the application.

-- 1. ENABLE ROW LEVEL SECURITY (Base)
alter table auth.users enable row level security;

-- 2. PUBLIC TABLES

-- PROFILES
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  email text, -- Added for Admin Panel management
  avatar_svg text,
  role text default 'user' check (role in ('user', 'admin')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.profiles enable row level security;

-- Drop existing policies to ensure clean slate if re-running
drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Users can insert their own profile." on profiles;
drop policy if exists "Users can update own profile." on profiles;
drop policy if exists "Admins can update any profile." on profiles;

create policy "Public profiles are viewable by everyone." on profiles for select using (true);
create policy "Users can insert their own profile." on profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on profiles for update using (auth.uid() = id);
-- Allow Admins to update ANY profile (needed for User Management)
create policy "Admins can update any profile." on profiles for update using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- APP SETTINGS (Global Config)
create table if not exists public.app_settings (
  id text primary key,
  allow_signup boolean default true,
  maintenance_mode boolean default false,
  updated_at timestamp with time zone default now()
);
alter table public.app_settings enable row level security;

drop policy if exists "Settings Viewable by Everyone" on app_settings;
drop policy if exists "Settings Updatable by Admin" on app_settings;

create policy "Settings Viewable by Everyone" on app_settings for select using (true);
create policy "Settings Updatable by Admin" on app_settings for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- Insert Default Settings
insert into public.app_settings (id, allow_signup) values ('config', true) on conflict (id) do nothing;


-- WORLDS
create table if not exists public.worlds (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  style text,
  level_range int[]
);
alter table public.worlds enable row level security;

drop policy if exists "Worlds are public." on worlds;
drop policy if exists "Admins can edit worlds." on worlds;

create policy "Worlds are public." on worlds for select using (true);
create policy "Admins can edit worlds." on worlds for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- PHASES
create table if not exists public.phases (
  id bigint generated by default as identity primary key,
  world_id bigint references public.worlds not null,
  title text not null,
  description text,
  order_index int default 0
);
alter table public.phases enable row level security;
drop policy if exists "Phases are public." on phases;
drop policy if exists "Admins can edit phases." on phases;

create policy "Phases are public." on phases for select using (true);
create policy "Admins can edit phases." on phases for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- LEVELS
create table if not exists public.levels (
  id bigint generated by default as identity primary key,
  phase_id bigint references public.phases,
  title text not null,
  type text not null,
  description text,
  map jsonb not null,
  start_pos jsonb not null,
  end_pos jsonb not null,
  perfect_score int,
  stars_2_threshold int,
  stars_1_threshold int,
  hint text,
  created_at timestamp with time zone default timezone('utc'::text, now())
);
alter table public.levels enable row level security;
drop policy if exists "Levels are public." on levels;
drop policy if exists "Admins can edit levels." on levels;

create policy "Levels are public." on levels for select using (true);
create policy "Admins can edit levels." on levels for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- PROGRESS
create table if not exists public.progress (
  user_id uuid references public.profiles not null,
  level_id bigint references public.levels not null,
  score int,
  stars int,
  completed_at timestamp with time zone default timezone('utc'::text, now()),
  primary key (user_id, level_id)
);
alter table public.progress enable row level security;
drop policy if exists "Users view own progress." on progress;
drop policy if exists "Users update own progress." on progress;

create policy "Users view own progress." on progress for select using (auth.uid() = user_id);
create policy "Users update own progress." on progress for all using (auth.uid() = user_id);
-- Include Admin capability to delete progress (cascade logic usually handles it, but good to have)

-- 3. ADMIN RPC FUNCTIONS

-- DELETE USER ADMIN (Clean Cascade Delete)
create or replace function public.delete_user_admin(target_user_id uuid)
returns void
language plpgsql
security definer
as $$
begin
  -- 1. Security Check
  if not exists (select 1 from public.profiles where id = auth.uid() and role = 'admin') then
    raise exception 'Access Denied';
  end if;

  -- 2. Manual Cascade Delete (To prevent Foreign Key errors)
  delete from public.progress where user_id = target_user_id;
  delete from public.profiles where id = target_user_id;

  -- 3. Delete from Auth (The actual user account)
  delete from auth.users where id = target_user_id;
end;
$$;

-- UPDATE USER EMAIL ADMIN
create or replace function public.update_user_email_admin(target_user_id uuid, new_email text)
returns void
language plpgsql
security definer
as $$
begin
  if not exists (select 1 from public.profiles where id = auth.uid() and role = 'admin') then
    raise exception 'Access Denied';
  end if;
  update auth.users set email = new_email, updated_at = now() where id = target_user_id;
  update public.profiles set email = new_email where id = target_user_id;
end;
$$;

-- Grant permissions for RPCs
grant execute on function public.delete_user_admin to authenticated;
grant execute on function public.update_user_email_admin to authenticated;

-- 4. CLEANUP LEGACY TRIGGERS
-- Ensure the flashing/race-condition causing trigger is gone
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user();

-- 5. CONTENT MANAGEMENT (SEED & RESTORE)

-- FUNCTION: RESET LEVEL DATA
-- Allows Admins to restore the original 14 Levels, Worlds, and Phases.
create or replace function public.reset_level_data()
returns void
language plpgsql
security definer
as $$
DECLARE
    p_seq_id bigint;
    p_ori_id bigint;
    p_loop_id bigint;
    p_cond_id bigint;
    p_adv_id bigint;
BEGIN
    -- 1. Security Check
    if not exists (select 1 from public.profiles where id = auth.uid() and role = 'admin') then
        raise exception 'Access Denied';
    end if;

    -- 2. RESTORE WORLDS
    insert into public.worlds (id, title, description, style, level_range)
    overriding system value
    values (1, 'Mundo 1: L贸gica & Algoritmos', 'Aprende los fundamentos de la programaci贸n.', 'cyberpunk', '{0,13}')
    on conflict (id) do update set 
        title = EXCLUDED.title,
        description = EXCLUDED.description;

    -- 3. RESTORE PHASES
    -- We delete and recreate phases for World 1 to ensure clean IDs if possible, 
    -- OR just Upsert based on Title+WorldID if we had a unique constraint.
    -- Simple approach: Upsert by Title (assuming titles don't change often).
    -- But we don't have a unique constraint on (world_id, title) by default.
    -- Let's just Insert IF NOT EXISTS to avoid duplicates, or delete old ones first?
    -- Safest for "Restore": Update existing by ID if known, or Title.
    -- Let's use INSERT ... DO NOTHING/UPDATE based on explicit IDs if we can.
    -- Since we didn't force IDs for phases in the original seed, let's look them up or create them.
    
    -- Helper to get/create phase
    -- (We will just insert them and let duplication happen if we run this often WITHOUT unique constraints? NO.)
    -- Let's ensure idempotency by checking existence.

    -- Link Phases (Upsert-ish logic)
    IF NOT EXISTS (SELECT 1 FROM phases where title = 'Secuenciaci贸n') THEN
        INSERT INTO phases (world_id, title, description, order_index) VALUES (1, 'Secuenciaci贸n', 'Pasos b谩sicos y orden.', 1);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM phases where title = 'Orientaci贸n') THEN
        INSERT INTO phases (world_id, title, description, order_index) VALUES (1, 'Orientaci贸n', 'Giros y movimiento espacial.', 2);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM phases where title = 'Bucles & Patron') THEN
        INSERT INTO phases (world_id, title, description, order_index) VALUES (1, 'Bucles & Patron', 'Repetici贸n eficiente.', 3);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM phases where title = 'Estado (Llaves)') THEN
        INSERT INTO phases (world_id, title, description, order_index) VALUES (1, 'Estado (Llaves)', 'Condicionales y memoria.', 4);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM phases where title = 'L贸gica Avanzada') THEN
        INSERT INTO phases (world_id, title, description, order_index) VALUES (1, 'L贸gica Avanzada', 'Portales y retos complejos.', 5);
    END IF;

    -- Get IDs for Level Insertion
    SELECT id INTO p_seq_id FROM public.phases WHERE title = 'Secuenciaci贸n' LIMIT 1;
    SELECT id INTO p_ori_id FROM public.phases WHERE title = 'Orientaci贸n' LIMIT 1;
    SELECT id INTO p_loop_id FROM public.phases WHERE title = 'Bucles & Patron' LIMIT 1;
    SELECT id INTO p_cond_id FROM public.phases WHERE title = 'Estado (Llaves)' LIMIT 1;
    SELECT id INTO p_adv_id FROM public.phases WHERE title = 'L贸gica Avanzada' LIMIT 1;

    -- 4. RESTORE LEVELS
    -- We can match by TITLE to update, since IDs might be auto-gen if we didn't force them.
    -- But earlier we wanted to force IDs for Levels? The previous script didn't force IDs for levels.
    -- Let's Update based on Title for now, or Delete and Recreate (but that breaks progress).
    -- BEST: Update based on Title.
    
    -- Function to upsert level by title
    -- Phase 1
    PERFORM upsert_level_by_title(p_seq_id, 'El Primer Paso', 'Tutorial', 'Un algoritmo es una lista de pasos. Diles a tu robot que avance dos veces para llegar a la meta .', '[[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 2, 0, 0, 1], [1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":3,"y":1}', 2);
    PERFORM upsert_level_by_title(p_seq_id, 'La Ruta Exacta', 'B谩sico', 'La precisi贸n es clave. Cuenta las casillas: si das pasos de m谩s, chocar谩s.', '[[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":5,"y":1}', 4);

    -- Phase 2
    PERFORM upsert_level_by_title(p_ori_id, 'El Giro', 'Giros', 'Girar cambia tu direcci贸n, pero no te mueve. Gira y luego avanza.', '[[1, 1, 1, 1, 1], [1, 1, 0, 0, 1], [1, 0, 0, 1, 1], [1, 1, 1, 1, 1]]', '{"x":1,"y":2,"dir":1}', '{"x":3,"y":1}', 5);
    PERFORM upsert_level_by_title(p_ori_id, 'La Serpiente', 'Giros', 'Combina giros y pasos. Izquierda, derecha... 隆No te marees!', '[[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":1,"y":3}', 8);
    PERFORM upsert_level_by_title(p_ori_id, 'Media Vuelta', 'Giros', 'Te has metido en un callej贸n sin salida. Da media vuelta (gira dos veces) para salir.', '[[1, 1, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 1, 1]]', '{"x":3,"y":1,"dir":2}', '{"x":0,"y":1}', 5);

    -- Phase 3
    PERFORM upsert_level_by_title(p_loop_id, 'Trabajo Manual', 'Patrones', '驴Notas que repites lo mismo? Avanzar, Girar, Avanzar, Girar... Hazlo paso a paso esta vez.', '[[1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1]]', '{"x":1,"y":3,"dir":1}', '{"x":4,"y":1}', 9);
    PERFORM upsert_level_by_title(p_loop_id, 'Automatizaci贸n', 'Bucles', '隆Ahora usa el bot贸n BUCLE ! Escribe el patr贸n UNA vez y rep铆telo 3 veces.', '[[1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1]]', '{"x":1,"y":3,"dir":1}', '{"x":4,"y":1}', 6);
    PERFORM upsert_level_by_title(p_loop_id, 'El Corredor Infinito', 'Bucles', '8 pasos son muchos bloques... Usa un bucle para caminar todo el pasillo con una sola orden.', '[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":8,"y":1}', 2);

    -- Phase 4
    PERFORM upsert_level_by_title(p_cond_id, 'La Puerta Cerrada', 'Condicionales', 'El camino est谩 bloqueado . La llave  cambia las reglas: t贸mala para poder pasar.', '[[1, 1, 1, 1, 1, 1, 1], [1, 0, 2, 0, 3, 0, 1], [1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":5,"y":1}', 5);
    PERFORM upsert_level_by_title(p_cond_id, 'El Recado', 'Condicionales', 'Divide el problema: 1. Ve por la llave. 2. Regresa a la puerta.', '[[1, 1, 1, 1, 1, 1, 1], [1, 3, 0, 0, 0, 2, 1], [1, 1, 1, 1, 1, 1, 1]]', '{"x":2,"y":1,"dir":1}', '{"x":0,"y":1}', 10);

    -- Phase 5
    PERFORM upsert_level_by_title(p_adv_id, 'Teletransporte', 'Portales', 'Los caminos no siempre son rectos. Entra al portal  para saltar los muros.', '[[1, 1, 1, 1, 1, 1], [1, 0, 4, 1, 4, 1], [1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":4,"y":2}', 3);
    PERFORM upsert_level_by_title(p_adv_id, 'El Laberinto Roto', 'Debugging', 'Un camino est谩 roto. Analiza el mapa antes de programar y encuentra la ruta segura.', '[[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":2}', '{"x":5,"y":1}', 12);
    PERFORM upsert_level_by_title(p_adv_id, 'Reuniendo Conceptos', 'Avanzado', 'Bucles y Portales. Usa el bucle para llegar al portal r谩pidamente.', '[[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 4, 1, 4, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":7,"y":2}', 5);
    PERFORM upsert_level_by_title(p_adv_id, 'El Algoritmo Maestro', 'Boss', 'EXAMEN FINAL: Llave, Puerta y Portales. 隆Demuestra que eres un Code Hero!', '[[1, 1, 1, 1, 1, 1, 1], [1, 0, 2, 1, 0, 0, 1], [1, 0, 1, 1, 1, 3, 1], [1, 4, 0, 0, 0, 4, 1], [1, 1, 1, 1, 1, 1, 1]]', '{"x":1,"y":1,"dir":1}', '{"x":5,"y":1}', 15);

END;
$$;

-- HELPER PROCEDURE (To make upserts cleaner above)
create or replace function public.upsert_level_by_title(
    p_phase_id bigint, p_title text, p_type text, p_desc text, p_map jsonb, p_start jsonb, p_end jsonb, p_perfect int
) returns void language plpgsql as $$
BEGIN
    if exists (select 1 from levels where title = p_title) then
        update levels set 
            phase_id = p_phase_id, type = p_type, description = p_desc, map = p_map, 
            start_pos = p_start, end_pos = p_end, perfect_score = p_perfect
        where title = p_title;
    else
        insert into levels (phase_id, title, type, description, map, start_pos, end_pos, perfect_score)
        values (p_phase_id, p_title, p_type, p_desc, p_map, p_start, p_end, p_perfect);
    end if;
END;
$$;

-- Grant permissions
grant execute on function public.reset_level_data to authenticated;
grant execute on function public.upsert_level_by_title to authenticated;

-- Run it immediately for the install
select public.reset_level_data();  

SELECT 'CodeHero Database Installed & Seeded Successfully' as status;
